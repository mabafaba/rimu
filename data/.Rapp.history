SE(m2)
SE(m2)/SE(m1)
debug(svy2lmeNG)
m2<-svy2lmeNG(PV1MATH~ (1+ ST04Q01 |SCHOOLID)+ST04Q01*(PCGIRLS+SMRATIO)+MATHEFF+OPENPS, design=des)
n
debug(Vbeta)
c
n
m2<-svy2lmeNG(PV1MATH~ (1+ ST04Q01 |SCHOOLID)+ST04Q01*(PCGIRLS+SMRATIO)+MATHEFF+OPENPS, design=des)
n
debug(Vbeta)
c
n
str(inffun)
summary(inffun)
n
ni
str(stratPSU)
table(stratPSU)
n
by(stratPSU,centering, summary)
length(centering)
str(centering)
by(stratPSU,centered, summary)
Q
q()
library(svylme)
data(nzmaths)#
     des<-svydesign(id=~SCHOOLID+STIDSTD, strata=~STRATUM, nest=TRUE,#
             weights=~W_FSCHWT+condwt, data=nzmaths)#
     m1NG<-svy2lmeNG(PV1MATH~ (1+ ST04Q01 |SCHOOLID)+ST04Q01*(PCGIRLS+SMRATIO)+MATHEFF+OPENPS, design=des)
summary(xwr)
n
psu[ii][1:10]
n
summary(inffun)
ii[1:20]
summary(pw1)
(1/p1g)[c(3,14,14,92)]
p1w[c(3,14,14,92)]
pw1[c(3,14,14,92)]
pw1[1:10]
pw1[ii][1:10]
summary(pw1)
p1[1:10]
p1[c(1,10,100)]
p1[c(1,10,100,1000)]
xtwx
summary((xwr*pw1[ii])%*%solve(xtwx))
str(pw1)
summary((xwr*pw1)%*%solve(xtwx))
summary(ii)
q()
Q
q()
library(svylme)
data(nzmaths)#
     des<-svydesign(id=~SCHOOLID+STIDSTD, strata=~STRATUM, nest=TRUE,#
             weights=~W_FSCHWT+condwt, data=nzmaths)#
     m1NG<-svy2lmeNG(PV1MATH~ (1+ ST04Q01 |SCHOOLID)+ST04Q01*(PCGIRLS+SMRATIO)+MATHEFF+OPENPS, design=des)
ls()
n
n'
''
n
summary(inffun)
c
m1NG
library(svylme)
example(nzmaths)
system.time(m1NG<-svy2lmeNG(PV1MATH~ (1+ ST04Q01 |SCHOOLID)+ST04Q01*(PCGIRLS+SMRATIO)+MATHEFF+OPENPS, design=des))
system.time(m1NG<-svy2lme(PV1MATH~ (1+ ST04Q01 |SCHOOLID)+ST04Q01*(PCGIRLS+SMRATIO)+MATHEFF+OPENPS, design=des))
system.time(m1<-svy2lme(PV1MATH~ (1+ ST04Q01 |SCHOOLID)+ST04Q01*(PCGIRLS+SMRATIO)+MATHEFF+OPENPS, design=des,method="nested"))
m1
library(survey)
library(svylme)
library(sampling)
overlapsim<-function(N1,N2,n1,n2){#
#setting: notation#
N1=100 ## number of sampling cluster in the first stage (population level)#
N2=100 ##number of elements in each sampling cluster (population level)#
latitude<-1:N2#
longitude<-1:N1#
population<-expand.grid(lat=latitude,long=longitude)#
population$PSU<-population$long#
#
overlap=ceiling(N2*3/4)#
#
model_cluster<-function(population, overlap){#
   population$cluster<-numeric(nrow(population))#
   id<-ifelse(population$lat<=overlap, #
              population$long, #
              ((population$long+population$lat-overlap) %% N1)+1#
   )#
   population$cluster<-id#
   population	#
}#
#
population<-model_cluster(population, overlap)#
T=length(unique(population$cluster))#
#
#Model: parameter from random slope model  model#
truebeta1=1#
truebeta2=3#
truesigma2=1#
truetau2_11=0.8#
truetau_12=0.6#
truetau2_22=1#
PairCov<-matrix(c(truetau2_11, truetau_12, truetau_12, truetau2_22), nrow=2, byrow=T)#
###check positive definite #
#
truevalue<-c(truebeta1,truebeta2, truesigma2, truetau2_11, truetau_12, truetau2_22)#
names(truevalue)<-c("beta1", "beta2", "sigma2", "tau2_11", "tau_12", "tau2_22")#
#
##Population data#
re=mvrnorm(n=T, mu = c(0,0), Sigma = PairCov) #generate vector of random effect (a, b)#
population$a<-re[,1][population$cluster]#
population$b<-re[,2][population$cluster]#
#
population$x<-rnorm(N1*N2)+rnorm(T)[population$cluster]#
population$y<-with(population, truebeta1+a+truebeta2*x+b*x+rnorm(N1*N2,s=sqrt(truesigma2)))#
population$r=with(population, x*(y-truebeta1-truebeta2*x))#
population$ID_unit=with(population, 1:(N1*N2))#
#
#uninformative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
#n1=ceiling(N1/10) ##number of sampling cluster in the first stage (sample level)#
#n2=ceiling(N2/10) ##umber of elements in each sampling cluster ( sample level)#
#
# Using sampling package for two-stage sampling (First-stage: SRSWOR, Second-stage: SRSWOR ) #
##uninformative two-stage  sampling design (First-stage: SRSWOR, Second-stage: SRSWOR) and extracts the observed data#
##first-stage#
FirststageSRSWOR=srswor(n1, N1)#
FirststageSRSWORSample=subset(population, population$PSU%in% which(FirststageSRSWOR==1))#
#
#second-stage#
SecondstageSRSWOR=unlist(lapply(rep(n2,n1), function(v) return(srswor(v, N2))))#
TwostageSRSWORSample<-FirststageSRSWORSample[c(which(SecondstageSRSWOR==1)),] #
#
#informative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
##number of elements in each sampling cluster#
param=c(1.5, 0.45)#
#
n2informative= function(r, sc, param, N2){#
   a=rep(NA, length=length(unique(population$sc)))#
   b=rep(NA, length=length(unique(population$sc)))#
   for (i in unique(sc)){#
      a[i]=mean(r[sc==i])#
      b[i]=2*ceiling((param[1]*exp(-param[2]*a[i]))/(1 +param[1]*exp(-param[2]*a[i]))*N2/2)#
   }#
   b#
}#
#
##informative two-stage  sampling design (SRSWOR)[second-stage is informative] and extracts the observed data#
###second-stage#
    n2pop=n2informative(population$r,population$PSU, param ,N2)#
    n2is=n2pop*FirststageSRSWOR#
    SecondstageSRSWORis=unlist(lapply(n2is[c(which(n2is!=0))], function(v) return(srswor(v, N2))))#
    TwostageSRSWORSampleis=FirststageSRSWORSample[c(which(SecondstageSRSWORis==1)), ]#
#
    list(ignorable=TwostageSRSWORSample, informative=TwostageSRSWORSampleis)#
}
overlapsim(400,400,20,20)->a
rmvnorm
MASS::rmvnorm
MASS::mvrnorm
library(MASS)
overlapsim<-function(N1,N2,n1,n2){#
#setting: notation#
N1=100 ## number of sampling cluster in the first stage (population level)#
N2=100 ##number of elements in each sampling cluster (population level)#
latitude<-1:N2#
longitude<-1:N1#
population<-expand.grid(lat=latitude,long=longitude)#
population$PSU<-population$long#
#
overlap=ceiling(N2*3/4)#
#
model_cluster<-function(population, overlap){#
   population$cluster<-numeric(nrow(population))#
   id<-ifelse(population$lat<=overlap, #
              population$long, #
              ((population$long+population$lat-overlap) %% N1)+1#
   )#
   population$cluster<-id#
   population	#
}#
#
population<-model_cluster(population, overlap)#
T=length(unique(population$cluster))#
#
#Model: parameter from random slope model  model#
truebeta1=1#
truebeta2=3#
truesigma2=1#
truetau2_11=0.8#
truetau_12=0.6#
truetau2_22=1#
PairCov<-matrix(c(truetau2_11, truetau_12, truetau_12, truetau2_22), nrow=2, byrow=T)#
###check positive definite #
#
truevalue<-c(truebeta1,truebeta2, truesigma2, truetau2_11, truetau_12, truetau2_22)#
names(truevalue)<-c("beta1", "beta2", "sigma2", "tau2_11", "tau_12", "tau2_22")#
#
##Population data#
re=mvrnorm(n=T, mu = c(0,0), Sigma = PairCov) #generate vector of random effect (a, b)#
population$a<-re[,1][population$cluster]#
population$b<-re[,2][population$cluster]#
#
population$x<-rnorm(N1*N2)+rnorm(T)[population$cluster]#
population$y<-with(population, truebeta1+a+truebeta2*x+b*x+rnorm(N1*N2,s=sqrt(truesigma2)))#
population$r=with(population, x*(y-truebeta1-truebeta2*x))#
population$ID_unit=with(population, 1:(N1*N2))#
#
#uninformative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
#n1=ceiling(N1/10) ##number of sampling cluster in the first stage (sample level)#
#n2=ceiling(N2/10) ##umber of elements in each sampling cluster ( sample level)#
#
# Using sampling package for two-stage sampling (First-stage: SRSWOR, Second-stage: SRSWOR ) #
##uninformative two-stage  sampling design (First-stage: SRSWOR, Second-stage: SRSWOR) and extracts the observed data#
##first-stage#
FirststageSRSWOR=srswor(n1, N1)#
FirststageSRSWORSample=subset(population, population$PSU%in% which(FirststageSRSWOR==1))#
#
#second-stage#
SecondstageSRSWOR=unlist(lapply(rep(n2,n1), function(v) return(srswor(v, N2))))#
TwostageSRSWORSample<-FirststageSRSWORSample[c(which(SecondstageSRSWOR==1)),] #
#
#informative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
##number of elements in each sampling cluster#
param=c(1.5, 0.45)#
#
n2informative= function(r, sc, param, N2){#
   a=rep(NA, length=length(unique(population$sc)))#
   b=rep(NA, length=length(unique(population$sc)))#
   for (i in unique(sc)){#
      a[i]=mean(r[sc==i])#
      b[i]=2*ceiling((param[1]*exp(-param[2]*a[i]))/(1 +param[1]*exp(-param[2]*a[i]))*N2/2)#
   }#
   b#
}#
#
##informative two-stage  sampling design (SRSWOR)[second-stage is informative] and extracts the observed data#
###second-stage#
    n2pop=n2informative(population$r,population$PSU, param ,N2)#
    n2is=n2pop*FirststageSRSWOR#
    SecondstageSRSWORis=unlist(lapply(n2is[c(which(n2is!=0))], function(v) return(srswor(v, N2))))#
    TwostageSRSWORSampleis=FirststageSRSWORSample[c(which(SecondstageSRSWORis==1)), ]#
#
    list(ignorable=TwostageSRSWORSample, informative=TwostageSRSWORSampleis)#
}
a<-overlapsim(400,500,20,25)
str(a)
svy2lme(y~(1+x|cluster)+x,design=design_ign)
design_ign<-svydesign(id=~PSU,weights=200000/500)
design_ign<-svydesign(id=~PSU,weights=200000/500,data=a$ignorable)
design_ign
svytotal(~y,design_ign)
svy2lme(y~(1+x|cluster)+x,design=design_ign)
length(weights(design_ign))
overlapsim<-function(N1,N2,n1,n2){#
#setting: notation#
N1=100 ## number of sampling cluster in the first stage (population level)#
N2=100 ##number of elements in each sampling cluster (population level)#
latitude<-1:N2#
longitude<-1:N1#
population<-expand.grid(lat=latitude,long=longitude)#
population$PSU<-population$long#
#
overlap=ceiling(N2*3/4)#
#
model_cluster<-function(population, overlap){#
   population$cluster<-numeric(nrow(population))#
   id<-ifelse(population$lat<=overlap, #
              population$long, #
              ((population$long+population$lat-overlap) %% N1)+1#
   )#
   population$cluster<-id#
   population	#
}#
#
population<-model_cluster(population, overlap)#
T=length(unique(population$cluster))#
#
#Model: parameter from random slope model  model#
truebeta1=1#
truebeta2=3#
truesigma2=1#
truetau2_11=0.8#
truetau_12=0.6#
truetau2_22=1#
PairCov<-matrix(c(truetau2_11, truetau_12, truetau_12, truetau2_22), nrow=2, byrow=T)#
###check positive definite #
#
truevalue<-c(truebeta1,truebeta2, truesigma2, truetau2_11, truetau_12, truetau2_22)#
names(truevalue)<-c("beta1", "beta2", "sigma2", "tau2_11", "tau_12", "tau2_22")#
#
##Population data#
re=mvrnorm(n=T, mu = c(0,0), Sigma = PairCov) #generate vector of random effect (a, b)#
population$a<-re[,1][population$cluster]#
population$b<-re[,2][population$cluster]#
#
population$x<-rnorm(N1*N2)+rnorm(T)[population$cluster]#
population$y<-with(population, truebeta1+a+truebeta2*x+b*x+rnorm(N1*N2,s=sqrt(truesigma2)))#
population$r=with(population, x*(y-truebeta1-truebeta2*x))#
population$ID_unit=with(population, 1:(N1*N2))#
#
#uninformative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
#n1=ceiling(N1/10) ##number of sampling cluster in the first stage (sample level)#
#n2=ceiling(N2/10) ##umber of elements in each sampling cluster ( sample level)#
#
# Using sampling package for two-stage sampling (First-stage: SRSWOR, Second-stage: SRSWOR ) #
##uninformative two-stage  sampling design (First-stage: SRSWOR, Second-stage: SRSWOR) and extracts the observed data#
##first-stage#
FirststageSRSWOR=srswor(n1, N1)#
FirststageSRSWORSample=subset(population, population$PSU%in% which(FirststageSRSWOR==1))#
#
#second-stage#
SecondstageSRSWOR=unlist(lapply(rep(n2,n1), function(v) return(srswor(v, N2))))#
TwostageSRSWORSample<-FirststageSRSWORSample[c(which(SecondstageSRSWOR==1)),] #
    TwostageSRSWORSample$p1<-n1/N1#
        TwostageSRSWORSample$p2<-n2/N2#
#
#informative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
##number of elements in each sampling cluster#
param=c(1.5, 0.45)#
#
n2informative= function(r, sc, param, N2){#
   a=rep(NA, length=length(unique(population$sc)))#
   b=rep(NA, length=length(unique(population$sc)))#
   for (i in unique(sc)){#
      a[i]=mean(r[sc==i])#
      b[i]=2*ceiling((param[1]*exp(-param[2]*a[i]))/(1 +param[1]*exp(-param[2]*a[i]))*N2/2)#
   }#
   b#
}#
#
##informative two-stage  sampling design (SRSWOR)[second-stage is informative] and extracts the observed data#
###second-stage#
    n2pop=n2informative(population$r,population$PSU, param ,N2)#
    n2is=n2pop*FirststageSRSWOR#
    SecondstageSRSWORis=unlist(lapply(n2is[c(which(n2is!=0))], function(v) return(srswor(v, N2))))#
    TwostageSRSWORSampleis=FirststageSRSWORSample[c(which(SecondstageSRSWORis==1)), ]#
    TwostageSRSWORSampleis$p1<-n1/N1#
    TwostageSRSWORSampleis$p1<-n2is/N2#
    list(ignorable=TwostageSRSWORSample, informative=TwostageSRSWORSampleis)#
}
svy2lme(y~(1+x|cluster)+x,design=design_ign)
a<-overlapsim(400,500,20,25)
options(error=recover)
a<-overlapsim(400,500,20,25)
n2is
n2pop
str( SecondstageSRSWORis)
sum( SecondstageSRSWORis)
sum(n2is)
rep(n2is[n2is!=0],n2is[n2is!=0],)
N2
Q
overlapsim<-function(N1,N2,n1,n2){#
#setting: notation#
N1=100 ## number of sampling cluster in the first stage (population level)#
N2=100 ##number of elements in each sampling cluster (population level)#
latitude<-1:N2#
longitude<-1:N1#
population<-expand.grid(lat=latitude,long=longitude)#
population$PSU<-population$long#
#
overlap=ceiling(N2*3/4)#
#
model_cluster<-function(population, overlap){#
   population$cluster<-numeric(nrow(population))#
   id<-ifelse(population$lat<=overlap, #
              population$long, #
              ((population$long+population$lat-overlap) %% N1)+1#
   )#
   population$cluster<-id#
   population	#
}#
#
population<-model_cluster(population, overlap)#
T=length(unique(population$cluster))#
#
#Model: parameter from random slope model  model#
truebeta1=1#
truebeta2=3#
truesigma2=1#
truetau2_11=0.8#
truetau_12=0.6#
truetau2_22=1#
PairCov<-matrix(c(truetau2_11, truetau_12, truetau_12, truetau2_22), nrow=2, byrow=T)#
###check positive definite #
#
truevalue<-c(truebeta1,truebeta2, truesigma2, truetau2_11, truetau_12, truetau2_22)#
names(truevalue)<-c("beta1", "beta2", "sigma2", "tau2_11", "tau_12", "tau2_22")#
#
##Population data#
re=mvrnorm(n=T, mu = c(0,0), Sigma = PairCov) #generate vector of random effect (a, b)#
population$a<-re[,1][population$cluster]#
population$b<-re[,2][population$cluster]#
#
population$x<-rnorm(N1*N2)+rnorm(T)[population$cluster]#
population$y<-with(population, truebeta1+a+truebeta2*x+b*x+rnorm(N1*N2,s=sqrt(truesigma2)))#
population$r=with(population, x*(y-truebeta1-truebeta2*x))#
population$ID_unit=with(population, 1:(N1*N2))#
#
#uninformative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
#n1=ceiling(N1/10) ##number of sampling cluster in the first stage (sample level)#
#n2=ceiling(N2/10) ##umber of elements in each sampling cluster ( sample level)#
#
# Using sampling package for two-stage sampling (First-stage: SRSWOR, Second-stage: SRSWOR ) #
##uninformative two-stage  sampling design (First-stage: SRSWOR, Second-stage: SRSWOR) and extracts the observed data#
##first-stage#
FirststageSRSWOR=srswor(n1, N1)#
FirststageSRSWORSample=subset(population, population$PSU%in% which(FirststageSRSWOR==1))#
#
#second-stage#
SecondstageSRSWOR=unlist(lapply(rep(n2,n1), function(v) return(srswor(v, N2))))#
TwostageSRSWORSample<-FirststageSRSWORSample[c(which(SecondstageSRSWOR==1)),] #
    TwostageSRSWORSample$p1<-n1/N1#
        TwostageSRSWORSample$p2<-n2/N2#
#
#informative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
##number of elements in each sampling cluster#
param=c(1.5, 0.45)#
#
n2informative= function(r, sc, param, N2){#
   a=rep(NA, length=length(unique(population$sc)))#
   b=rep(NA, length=length(unique(population$sc)))#
   for (i in unique(sc)){#
      a[i]=mean(r[sc==i])#
      b[i]=2*ceiling((param[1]*exp(-param[2]*a[i]))/(1 +param[1]*exp(-param[2]*a[i]))*N2/2)#
   }#
   b#
}#
#
##informative two-stage  sampling design (SRSWOR)[second-stage is informative] and extracts the observed data#
###second-stage#
    n2pop=n2informative(population$r,population$PSU, param ,N2)#
    n2is=n2pop*FirststageSRSWOR#
    SecondstageSRSWORis=unlist(lapply(n2is[c(which(n2is!=0))], function(v) return(srswor(v, N2))))#
    TwostageSRSWORSampleis=FirststageSRSWORSample[c(which(SecondstageSRSWORis==1)), ]#
    TwostageSRSWORSampleis$p1<-n1/N1#
    TwostageSRSWORSampleis$p1<-rep(n2is[n2is!=0],n2is[n2is!=0],)/N2#
    list(ignorable=TwostageSRSWORSample, informative=TwostageSRSWORSampleis)#
}
a<-overlapsim(400,500,20,25)
design_ign<-svydesign(id=~PSU,prob=~p1+p2,data=a$ignorable)
names(a$ignorable)
table(duplicated(a$ignorable$ID_unit))
design_ign<-svydesign(id=~PSU+ID_unit,prob=~p1+p2,data=a$ignorable)
svy2lme(y~(1+x|cluster)+x,design=design_ign)
design_inf<-svydesign(id=~PSU+ID_unit,prob=~p1+p2,data=a$informative)#
svy2lme(y~(1+x|cluster)+x,design=design_inf)
overlapsim<-function(N1,N2,n1,n2){#
#setting: notation#
N1=100 ## number of sampling cluster in the first stage (population level)#
N2=100 ##number of elements in each sampling cluster (population level)#
latitude<-1:N2#
longitude<-1:N1#
population<-expand.grid(lat=latitude,long=longitude)#
population$PSU<-population$long#
#
overlap=ceiling(N2*3/4)#
#
model_cluster<-function(population, overlap){#
   population$cluster<-numeric(nrow(population))#
   id<-ifelse(population$lat<=overlap, #
              population$long, #
              ((population$long+population$lat-overlap) %% N1)+1#
   )#
   population$cluster<-id#
   population	#
}#
#
population<-model_cluster(population, overlap)#
T=length(unique(population$cluster))#
#
#Model: parameter from random slope model  model#
truebeta1=1#
truebeta2=3#
truesigma2=1#
truetau2_11=0.8#
truetau_12=0.6#
truetau2_22=1#
PairCov<-matrix(c(truetau2_11, truetau_12, truetau_12, truetau2_22), nrow=2, byrow=T)#
###check positive definite #
#
truevalue<-c(truebeta1,truebeta2, truesigma2, truetau2_11, truetau_12, truetau2_22)#
names(truevalue)<-c("beta1", "beta2", "sigma2", "tau2_11", "tau_12", "tau2_22")#
#
##Population data#
re=mvrnorm(n=T, mu = c(0,0), Sigma = PairCov) #generate vector of random effect (a, b)#
population$a<-re[,1][population$cluster]#
population$b<-re[,2][population$cluster]#
#
population$x<-rnorm(N1*N2)+rnorm(T)[population$cluster]#
population$y<-with(population, truebeta1+a+truebeta2*x+b*x+rnorm(N1*N2,s=sqrt(truesigma2)))#
population$r=with(population, x*(y-truebeta1-truebeta2*x))#
population$ID_unit=with(population, 1:(N1*N2))#
#
#uninformative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
#n1=ceiling(N1/10) ##number of sampling cluster in the first stage (sample level)#
#n2=ceiling(N2/10) ##umber of elements in each sampling cluster ( sample level)#
#
# Using sampling package for two-stage sampling (First-stage: SRSWOR, Second-stage: SRSWOR ) #
##uninformative two-stage  sampling design (First-stage: SRSWOR, Second-stage: SRSWOR) and extracts the observed data#
##first-stage#
FirststageSRSWOR=srswor(n1, N1)#
FirststageSRSWORSample=subset(population, population$PSU%in% which(FirststageSRSWOR==1))#
#
#second-stage#
SecondstageSRSWOR=unlist(lapply(rep(n2,n1), function(v) return(srswor(v, N2))))#
TwostageSRSWORSample<-FirststageSRSWORSample[c(which(SecondstageSRSWOR==1)),] #
    TwostageSRSWORSample$p1<-n1/N1#
        TwostageSRSWORSample$p2<-n2/N2#
#
#informative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
##number of elements in each sampling cluster#
param=c(1.5, 0.45)#
#
n2informative= function(r, sc, param, N2){#
   a=rep(NA, length=length(unique(population$sc)))#
   b=rep(NA, length=length(unique(population$sc)))#
   for (i in unique(sc)){#
      a[i]=mean(r[sc==i])#
      b[i]=2*ceiling((param[1]*exp(-param[2]*a[i]))/(1 +param[1]*exp(-param[2]*a[i]))*N2/2)#
   }#
   b#
}#
#
##informative two-stage  sampling design (SRSWOR)[second-stage is informative] and extracts the observed data#
###second-stage#
    n2pop=n2informative(population$r,population$PSU, param ,N2)#
    n2is=n2pop*FirststageSRSWOR#
    SecondstageSRSWORis=unlist(lapply(n2is[c(which(n2is!=0))], function(v) return(srswor(v, N2))))#
    TwostageSRSWORSampleis=FirststageSRSWORSample[c(which(SecondstageSRSWORis==1)), ]#
    TwostageSRSWORSampleis$p1<-n1/N1#
    TwostageSRSWORSampleis$p2<-rep(n2is[n2is!=0],n2is[n2is!=0],)/N2#
    list(ignorable=TwostageSRSWORSample, informative=TwostageSRSWORSampleis)#
}
a<-overlapsim(400,500,20,25)#
design_ign<-svydesign(id=~PSU+ID_unit,prob=~p1+p2,data=a$ignorable)#
svy2lme(y~(1+x|cluster)+x,design=design_ign)#
#
design_inf<-svydesign(id=~PSU+ID_unit,prob=~p1+p2,data=a$informative)#
svy2lme(y~(1+x|cluster)+x,design=design_inf)
overlapsim<-function(N1,N2,n1,n2,overlap_f=0.8){#
#setting: notation#
latitude<-1:N2#
longitude<-1:N1#
population<-expand.grid(lat=latitude,long=longitude)#
population$PSU<-population$long#
#
overlap=ceiling(N2*overlap_f)#
#
model_cluster<-function(population, overlap){#
   population$cluster<-numeric(nrow(population))#
   id<-ifelse(population$lat<=overlap, #
              population$long, #
              ((population$long+population$lat-overlap) %% N1)+1#
   )#
   population$cluster<-id#
   population	#
}#
#
population<-model_cluster(population, overlap)#
T=length(unique(population$cluster))#
#
#Model: parameter from random slope model  model#
truebeta1=1#
truebeta2=3#
truesigma2=1#
truetau2_11=0.8#
truetau_12=0.6#
truetau2_22=1#
PairCov<-matrix(c(truetau2_11, truetau_12, truetau_12, truetau2_22), nrow=2, byrow=T)#
###check positive definite #
#
truevalue<-c(truebeta1,truebeta2, truesigma2, truetau2_11, truetau_12, truetau2_22)#
names(truevalue)<-c("beta1", "beta2", "sigma2", "tau2_11", "tau_12", "tau2_22")#
#
##Population data#
re=mvrnorm(n=T, mu = c(0,0), Sigma = PairCov) #generate vector of random effect (a, b)#
population$a<-re[,1][population$cluster]#
population$b<-re[,2][population$cluster]#
#
population$x<-rnorm(N1*N2)+rnorm(T)[population$cluster]#
population$y<-with(population, truebeta1+a+truebeta2*x+b*x+rnorm(N1*N2,s=sqrt(truesigma2)))#
population$r=with(population, x*(y-truebeta1-truebeta2*x))#
population$ID_unit=with(population, 1:(N1*N2))#
#
#uninformative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
#n1=ceiling(N1/10) ##number of sampling cluster in the first stage (sample level)#
#n2=ceiling(N2/10) ##umber of elements in each sampling cluster ( sample level)#
#
# Using sampling package for two-stage sampling (First-stage: SRSWOR, Second-stage: SRSWOR ) #
##uninformative two-stage  sampling design (First-stage: SRSWOR, Second-stage: SRSWOR) and extracts the observed data#
##first-stage#
FirststageSRSWOR=srswor(n1, N1)#
FirststageSRSWORSample=subset(population, population$PSU%in% which(FirststageSRSWOR==1))#
#
#second-stage#
SecondstageSRSWOR=unlist(lapply(rep(n2,n1), function(v) return(srswor(v, N2))))#
TwostageSRSWORSample<-FirststageSRSWORSample[c(which(SecondstageSRSWOR==1)),] #
    TwostageSRSWORSample$p1<-n1/N1#
        TwostageSRSWORSample$p2<-n2/N2#
#
#informative two-stage sampling design (first-stage: SRSWOR, Second-stage:SRSWOR)#
##number of elements in each sampling cluster#
param=c(1.5, 0.45)#
#
n2informative= function(r, sc, param, N2){#
   a=rep(NA, length=length(unique(population$sc)))#
   b=rep(NA, length=length(unique(population$sc)))#
   for (i in unique(sc)){#
      a[i]=mean(r[sc==i])#
      b[i]=2*ceiling((param[1]*exp(-param[2]*a[i]))/(1 +param[1]*exp(-param[2]*a[i]))*N2/2)#
   }#
   b#
}#
#
##informative two-stage  sampling design (SRSWOR)[second-stage is informative] and extracts the observed data#
###second-stage#
    n2pop=n2informative(population$r,population$PSU, param ,N2)#
    n2is=n2pop*FirststageSRSWOR#
    SecondstageSRSWORis=unlist(lapply(n2is[c(which(n2is!=0))], function(v) return(srswor(v, N2))))#
    TwostageSRSWORSampleis=FirststageSRSWORSample[c(which(SecondstageSRSWORis==1)), ]#
    TwostageSRSWORSampleis$p1<-n1/N1#
    TwostageSRSWORSampleis$p2<-rep(n2is[n2is!=0],n2is[n2is!=0],)/N2#
    list(ignorable=TwostageSRSWORSample, informative=TwostageSRSWORSampleis)#
}#
a<-overlapsim(400,500,20,25)#
design_ign<-svydesign(id=~PSU+ID_unit,prob=~p1+p2,data=a$ignorable)#
svy2lme(y~(1+x|cluster)+x,design=design_ign)#
#
design_inf<-svydesign(id=~PSU+ID_unit,prob=~p1+p2,data=a$informative)#
svy2lme(y~(1+x|cluster)+x,design=design_inf)
a<-overlapsim(400,500,20,25)#
design_ign<-svydesign(id=~PSU+ID_unit,prob=~p1+p2,data=a$ignorable)#
m_ig<-svy2lme(y~(1+x|cluster)+x,design=design_ign)#
#
design_inf<-svydesign(id=~PSU+ID_unit,prob=~p1+p2,data=a$informative)#
m_inf<-svy2lme(y~(1+x|cluster)+x,design=design_inf)
m_ig
m_inf
coef(m_ig)
coef(m_ig,random=TRUE)
str(m_ig)
c(ig=c(coef(m_ig), m_ig$opt$par, m_ig$s2, SE(m_ig)), inf=c(coef(m_inf), m_inf$opt$par, m_inf$s2, SE(m_inf)))
library(lme4qtl)
library(help=lme4qtl)
? relmatLmer
?stepAIC
library(MASS)
?stepAIC
library(tidyverse)
week2<-read_csv("~/Downloads/week2.csv")
model.matrix(tip_amount~.,data=week2[1:100,])
20600+141400+357300
20600+141400+357300+(4768600-4699800)
p0
alpha<-0.05#
p0<-0.1/100*3#
p1<-0.45/100*3
size<-(0.0045-0.001)*3
p0-p1
size
root <- size^2*n/(p0*(1-p0)+p1*(1+p1))
n<-6441
root <- size^2*n/(p0*(1-p0)+p1*(1+p1))
root
size
size^2
size^2*n
root <- size^2*n/(p0*(1-p0)+p1*(1-p1))
root
sqrt(root)
sqrt(root)+1.96
pnorm(8.55)
pnorm(8.55,lower.tail=TRUE)
pnorm(8.55,lower.tail=FALSE)
(p0*(1-p0)+p1*(1-p1))
size^2/(p0*(1-p0)+p1*(1-p1))
size^2/(p0*(1-p0)+p1*(1-p1))*n
library(splines)
?ns
a<-read.csv("~/Downloads/ta-lodged-bonds.csv")
str(a)
tt<-rowSums(a[,-1])
tt<-rowSums(a[,-1],na.rm=TRUE)
plot(tt)
mean(tt[-(1:100)])
b<-read.csv("~/Downloads/ta-active-bonds.csv")
ss<-rowSums(b[,-1])
ss<-rowSums(b[,-1],na.rm=TRUE)
plot(ss)
mean(diff(ss))
mean(tt[-(1:100)])/mean(ss[-(1:100)])
d<-read.csv("~/Downloads/ta-closed-bonds.csv")
vv<-rowSums(d[,-1],na.rm=TRUE)
plot(vv)
mean(vv[-(1:100)])
mean(vv[-(1:100)])/mean(ss[-(1:100)])
yrbs<-read.csv("~/XXHqn.csv")
head(yrbs)
table(yrbs$Q5)
dim(yrbs)
mr
library(rimu)
race<-as.mr(strsplit(yrbs$Q5,""))
race<-as.mr(strsplit(as.character(yrbs$Q5),""))
race[1:10]
str(race)
str(strsplit(as.character(yrbs$Q5),""))
rimu:::as.mr.list
debug(rimu:::as.mr.list)
race<-as.mr(strsplit(as.character(yrbs$Q5),""))
n
levs
n
n
str(m)
levs %in% x[[1]]
levs %in% x[[2]]
x[[2]]
x[[3]]
n
n
n
n
n
n
n
n
n
n
i
m[1:10,]
c
str(m)
Q
as.mr.list<-function(x,...,levels=NULL){#
    levs<-unique(do.call(c,x))#
    if (!is.null(levels)){#
        if (any(xtra<-setdiff(levs,levels)))#
            warning(paste("values not in 'levels' ",paste(xtra,collapse=", ")))#
        levs<-levels#
    }#
    m<-matrix(FALSE,nrow=length(x),ncol=length(levs))#
    for(i in seq_along(x)){#
        m[i,]<-levs %in% x[[i]]#
    }#
    colnames(m)<-levs#
    class(m)<-mr#
    m#
}
race<-as.mr.list(strsplit(as.character(yrbs$Q5),""))
as.mr.list<-function(x,...,levels=NULL){#
    levs<-unique(do.call(c,x))#
    if (!is.null(levels)){#
        if (any(xtra<-setdiff(levs,levels)))#
            warning(paste("values not in 'levels' ",paste(xtra,collapse=", ")))#
        levs<-levels#
    }#
    m<-matrix(FALSE,nrow=length(x),ncol=length(levs))#
    for(i in seq_along(x)){#
        m[i,]<-levs %in% x[[i]]#
    }#
    colnames(m)<-levs#
    class(m)<-"mr"#
    m#
}
race<-as.mr.list(strsplit(as.character(yrbs$Q5),""))
str(race)
race[1:20]
race[1:20,]
levels(race)
yrbs$Q5[1:40]
yrbs$Q5[1:60]
mtable(race)
mtable(race,race)
names(yrbs)
summary(yrbs$QN46)
mtable(race, yrbs$QN30)
mtable(race, yrbs$QN31)
as.mr.logical<-function(x,name,...){#
    if (!is.matrix(x)){#
        x<-matrix(x,ncol=1)#
        colnames(x)<-name#
    } else{#
        if (!missing(name))#
            colnames(x)<-name#
    }#
    class(x)<-"mr"#
    x#
    }
table(yrbs$Q4)
hispanic<-as.mr(yrbs$Q4==1,"Hispanic")
hispanic[1:10]
ethrace<-mr_union(race,hispanic)
ethrace[1:20,]
yrbs<-yrbs[,c("Q4","Q5","QN30","QN31")]
object.size(yrbs)
yrbs<-yrbs[sample(nrow(yrbs),5000),]
object.size(yrbs)
yrbs<-read.csv("~/XXHqn.csv")
yrbs<-yrbs[,c("Q4","Q5","QN30","QN31")]
save(yrbs,file="~/rimu/data/usethnicity.rda")
getwd()
setwd("rimu")
setwd("man")
usethnicty<-yrbs
usethnicity<-yrbs
prompt(usethnicity)
setwd("../data")
save(usethnicity,file="~/rimu/data/usethnicity.rda")
str(usethnicity)
usethnicity$Q5<-as.character(usethnicity$Q5)
str(usethnicity)
save(usethnicity,file="~/rimu/data/usethnicity.rda")
q()
